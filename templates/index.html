<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rerun Server</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        :root {
            --bg-primary: #0f1113;
            --bg-secondary: #171a1d;
            --bg-tertiary: #1f2327;
            --bg-logs: #111417;
            --text-primary: #e6e8ea;
            --text-secondary: #9aa0a6;
            --border-color: #2c3136;
            --success-color: #1a7f37;
            --danger-color: #c0353a;
            --warning-color: #f59e0b;
            --info-color: #58a6ff;
        }
        
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .container {
            max-width: 1200px;
            margin-top: 40px;
            padding: 28px;
            background-color: var(--bg-secondary);
            border-radius: 14px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.4);
        }
        
        h1 {
            font-size: 1.6rem;
            font-weight: 600;
        }
        
        .form-label {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .hint {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        
        .btn-start {
            background-color: var(--success-color);
            color: #fff;
            border: none;
        }
        
        .btn-start:hover {
            background-color: #22863a;
            color: #fff;
        }
        
        .btn-stop {
            background-color: var(--danger-color);
            color: #fff;
            border: none;
        }
        
        .btn-stop:hover {
            background-color: #d73a49;
            color: #fff;
        }
        
        select, input {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color) !important;
        }
        
        select:focus, input:focus {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
            border-color: var(--success-color) !important;
            box-shadow: 0 0 0 0.25rem rgba(26, 127, 55, 0.25) !important;
        }
        
        .logs {
            background-color: var(--bg-logs);
            border: 1px solid var(--border-color);
            padding: 15px;
            height: 280px;
            overflow-y: auto;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 10px;
            transition: all 0.3s ease;
        }
        
        .dot.online {
            background-color: var(--success-color);
            box-shadow: 0 0 10px rgba(26,127,55,0.8);
            animation: pulse 2s infinite;
        }
        
        .dot.offline {
            background-color: #555b61;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(26,127,55,0.7); }
            70% { box-shadow: 0 0 0 10px rgba(26,127,55,0); }
            100% { box-shadow: 0 0 0 0 rgba(26,127,55,0); }
        }
        
        .alert {
            border: none;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .alert-danger {
            background-color: rgba(192, 53, 58, 0.1);
            color: #f85149;
            border-left: 4px solid var(--danger-color);
        }
        
        .alert-success {
            background-color: rgba(26, 127, 55, 0.1);
            color: #56d364;
            border-left: 4px solid var(--success-color);
        }
        
        /* Destination management styles */
        .destination-row {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }
        
        .destination-counter {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .destination-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .destination-inputs input {
            flex: 1;
        }
        
        .btn-add-destination {
            background-color: var(--success-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-add-destination:hover {
            background-color: #22863a;
        }
        
        .btn-remove-destination {
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        
        .btn-remove-destination:hover {
            background-color: #d73a49;
        }

        /* CATEGORY SELECTOR STYLES */
        .category-selector {
            background-color: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 24px;
        }
        .category-btn {
            border-color: var(--border-color) !important;
            color: var(--text-primary) !important;
        }
        .category-btn.active {
            background-color: var(--success-color) !important;
            border-color: var(--success-color) !important;
            color: white !important;
        }
        .category-btn:hover:not(.active) {
            background-color: var(--bg-secondary) !important;
        }
        
        @media (max-width: 768px) {
            .container {
                margin-top: 20px;
                padding: 20px;
            }
            
            .logs {
                height: 200px;
            }
            
            .destination-inputs {
                flex-direction: column;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="status-bar">
            <div>
                <h1 class="m-0">
                    Rerun 24/7
                    <span id="status-dot" class="dot offline" title="Offline"></span>
                </h1>
                <div class="stats mt-1">
                    <span id="stats-text">Ready to stream</span>
                </div>
            </div>
            <div class="text-end">
                <div class="hint">
                    <strong>GPU Support:</strong><br>
                    NVIDIA<span class="badge bg-success ms-1">NVENC</span>
                    Intel<span class="badge bg-info ms-1">VAAPI</span>
                </div>
            </div>
        </div>

        <!-- CATEGORY SELECTOR UI -->
        <div class="category-selector">
            <h4>Content Category</h4>
            <div class="hint mb-2">Select which type of content to stream</div>
            <div class="btn-group" role="group">
                <button type="button" class="btn btn-outline-primary category-btn active" data-category="all">
                    <i class="bi bi-collection"></i> All Videos
                </button>
                <button type="button" class="btn btn-outline-primary category-btn" data-category="justchatting">
                    <i class="bi bi-chat-dots"></i> Just Chatting
                </button>
                <button type="button" class="btn btn-outline-primary category-btn" data-category="pool">
                    <i class="bi bi-water"></i> Pool
                </button>
            </div>
            <div class="hint mt-2" id="category-stats">Loading...</div>
        </div>

        <div class="row">
            <div class="col-md-6">
                <h4>Stream Destinations</h4>
                <div class="hint mb-3">Configure streaming URLs and keys for multiple platforms</div>
                
                <div id="destinations-container">
                    <!-- Dynamic destinations will be populated here -->
                </div>
                
                <div class="d-flex gap-2 mb-4">
                    <button type="button" class="btn-add-destination" id="add-destination-btn" title="Add another destination">
                        +
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" onclick="saveDestinations()">
                        <i class="bi bi-save"></i> Save Destinations
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-sm" onclick="resetDestinations()">
                        <i class="bi bi-arrow-clockwise"></i> Reset to Defaults
                    </button>
                </div>
            </div>
            
            <div class="col-md-6">
                <h4>Stream Configuration</h4>
                
                <form id="stream-form" class="mt-3">
                    <div class="row g-3">
                        <!-- Bitrate -->
                        <div class="col-md-6">
                            <label for="bitrate" class="form-label">Video Bitrate</label>
                            <input 
                                type="text" 
                                class="form-control" 
                                id="bitrate" 
                                name="bitrate"
                                placeholder="2500k" 
                                value="{{ form.bitrate if form.bitrate else '2500k' }}"
                                pattern="^\d+k?$"
                                title="Enter bitrate like '2500k' or '2500'"
                            >
                            <div class="hint">Format: 2500k or 2500</div>
                        </div>
                        <!-- Input Type -->
                        <div class="col-md-6">
                            <label for="input_type" class="form-label">Input Source</label>
                            <select class="form-select" id="input_type" name="input_type">
                                <option value="file" {% if form.input_type == 'file' %}selected{% endif %}>Local Video File</option>
                                <option value="srt" {% if form.input_type == 'srt' %}selected{% endif %}>SRT / RTMP Stream</option>
                            </select>
                        </div>
                        <!-- Video Selection (for file input) -->
                        <div class="col-12" id="video-selection">
                            <label for="video", class="form-label">Select Video File</label>
                            <select class="form-select" id="video" name="video">
                                <option value="">Loading videos...</option>
                                {% for video in videos %}
                                    <option value="{{ video }}" {% if form.video == video %}selected{% endif %}>{{ video }}</option>
                                {% endfor %}
                            </select>
                            <div class="hint">Upload videos to the configured video folder</div>
                        </div>
                        <!-- SRT URL (for stream input) -->
                        <div class="col-12" id="srt-input" style="display:none;">
                            <label for="srt_url" class="form-label">SRT / RTMP Input URL</label>
                            <input 
                                type="url" 
                                class="form-control" 
                                id="srt_url" 
                                name="srt_url"
                                placeholder="srt://host:port?streamid=publish/live/stream_key"
                                value="{{ form.srt_url if form.srt_url else '' }}"
                            >
                            <div class="hint">Enter the full SRT or RTMP input URL</div>
                        </div>
                        <!-- Encoder -->
                        <div class="col-md-6">
                            <label for="encoder" class="form-label">Video Encoder</label>
                            <select class="form-select", id="encoder", name="encoder">
                                <option value="libx264" {% if form.encoder == 'libx264' %}selected{% endif %}>CPU (x264)</option>
                                <option value="h264_nvenc" {% if form.encoder == 'h264_nvenc' %}selected{% endif %}>NVIDIA GPU (NVENC)</option>
                                <option value="h264_vaapi" {% if form.encoder == 'h264_vaapi' %}selected{% endif %}>Intel iGPU (VAAPI)</option>
                            </select>
                            <div class="hint mt-1", id="encoder-help">CPU encoding works on all systems</div>
                        </div>
                        <!-- Preset -->
                        <div class="col-md-6">
                            <label for="preset" class="form-label">Encoder Preset</label>
                            <select class="form-select", id="preset", name="preset">
                                <!-- Options will be populated by JavaScript -->
                            </select>
                            <div class="hint mt-1", id="preset-help">Preset affects encoding speed vs quality</div>
                        </div>
                        <!-- Shuffle Mode -->
                        <div class="col-12">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="shuffle_mode" name="shuffle_mode" {% if form.shuffle_mode == 'true' %}checked{% endif %}>
                                <label class="form-check-label" for="shuffle_mode">Shuffle Playlist</label>
                            </div>
                            <div class="hint">Randomly play videos from your library</div>
                        </div>
                    </div>
                    <!-- Control Buttons -->
                    <div class="d-flex gap-2 mt-4">
                        <button id="toggle-btn" type="button" class="btn btn-start px-4">
                            <span id="toggle-text">Start Stream</span>
                        </button>
                        <button id="skip-btn" type="button" class="btn btn-outline-warning" disabled>
                            <i class="bi bi-skip-forward"></i> Skip Video
                        </button>
                        <button type="button" class="btn btn-outline-secondary" onclick="clearLogs()">
                            <i class="bi bi-trash"></i> Clear Logs
                        </button>
                    </div>
                </form>
            </div>
        </div>
        <!-- Error/Success Messages -->
        <div id="messages"></div>
        <!-- Logs -->
        <div class="logs" id="logs"></div>
    </div>
  <script>
        // DOM elements
        const form = document.getElementById("stream-form");
        const inputType = document.getElementById("input_type");
        const videoSelection = document.getElementById("video-selection");
        const srtInput = document.getElementById("srt-input");
        const encoder = document.getElementById("encoder");
        const preset = document.getElementById("preset");
        const encoderHelp = document.getElementById("encoder-help");
        const presetHelp = document.getElementById("preset-help");
        const statusDot = document.getElementById("status-dot");
        const statsText = document.getElementById("stats-text");
        const logsEl = document.getElementById("logs");
        const toggleBtn = document.getElementById("toggle-btn");
        const toggleText = document.getElementById("toggle-text");
        const skipBtn = document.getElementById("skip-btn");
        const messagesDiv = document.getElementById("messages");
        const destinationsContainer = document.getElementById("destinations-container");
        const addDestinationBtn = document.getElementById("add-destination-btn");
        const shuffleMode = document.getElementById("shuffle_mode");
        const videoSelect = document.getElementById("video");
        const categoryStats = document.getElementById("category-stats");

        // Store the initially selected video from server-side rendering
        const initiallySelectedVideo = "{{ form.video if form.video else '' }}";
        let currentVideoSelection = initiallySelectedVideo;

        // Dynamic destinations management
        let destinations = [];
        let nextId = 5;

        // Preset configurations
        const PRESET_OPTIONS = {
            "libx264": {
                "ultrafast": "Ultra Fast (lowest quality)",
                "superfast": "Super Fast",
                "veryfast": "Very Fast",
                "faster": "Faster",
                "fast": "Fast",
                "medium": "Medium (balanced)",
                "slow": "Slow (better quality)",
                "slower": "Slower",
                "veryslow": "Very Slow (best quality)"
            },
            "h264_nvenc": {
                "p1": "P1 (fastest)",
                "p2": "P2",
                "p3": "P3",
                "p4": "P4 (balanced)",
                "p5": "P5",
                "p6": "P6",
                "p7": "P7 (best quality)",
                "ll": "Low Latency",
                "llhp": "LL High Performance",
                "llhq": "LL High Quality"
            },
            "h264_vaapi": {
                "medium": "Medium (default)",
                "fast": "Fast",
                "slow": "Slow"
            }
        };
        const DEFAULT_PRESETS = {
            "libx264": "medium",
            "h264_nvenc": "p4",
            "h264_vaapi": "medium"
        };
        const ENCODER_HELP = {
            "libx264": "CPU encoding: slower presets = better quality",
            "h264_nvenc": "NVIDIA GPU encoding: P1-P7 for speed→quality, LL* for low latency",
            "h264_vaapi": "Intel GPU encoding: efficient for streaming"
        };

        // Category management
        let currentCategory = "all";

        function updateCategoryUI(category) {
            document.querySelectorAll(".category-btn").forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add("active");
                } else {
                    btn.classList.remove("active");
                }
            });
            currentCategory = category;
        }

        async function setCategory(category) {
            try {
                const response = await fetch("/category", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ category: category })
                });
                const data = await response.json();
                
                if (!response.ok) {
                    showMessage(data.error || "Failed to switch category", "danger");
                } else {
                    updateCategoryUI(category);
                    showMessage(`Switched to ${category} category`, "success");
                    await loadVideos(true); // Force reload videos
                    await updateCategoryStats();
                }
            } catch (error) {
                showMessage("Network error: " + error.message, "danger");
            }
        }

        async function updateCategoryStats() {
            try {
                const response = await fetch("/category/stats");
                if (!response.ok) {
                    throw new Error('Failed to fetch category stats');
                }
                const data = await response.json();
                if (data.all !== undefined) {
                    categoryStats.textContent = `All: ${data.all} | Just Chatting: ${data.justchatting} | Pool: ${data.pool}`;
                } else if (data.error) {
                    categoryStats.textContent = "Error: " + data.error;
                } else {
                    categoryStats.textContent = "No stats available";
                }
            } catch (error) {
                console.error("Failed to get category stats:", error);
                categoryStats.textContent = "Error loading stats";
            }
        }

        // Load destinations from backend on page load
        async function loadDestinations() {
            try {
                const response = await fetch("/destinations");
                const data = await response.json();
                
                if (data.destinations && data.destinations.length > 0) {
                    destinations = data.destinations.map(dest => ({
                        id: dest.id,
                        url: dest.url || "",
                        key: dest.key || "",
                        enabled: dest.enabled || false
                    }));
                } else {
                    // Initialize with defaults including stream key fields
                    destinations = [
                        { id: 1, url: "rtmp://live.twitch.tv/app/", key: "", enabled: false },
                        { id: 2, url: "rtmp://a.rtmp.youtube.com/live2/", key: "", enabled: false },
                        { id: 3, url: "rtmps://live-api-s.facebook.com:443/rtmp/", key: "", enabled: false },
                        { id: 4, url: "rtmp://rtmp.kick.com:1935/live/", key: "", enabled: false }
                    ];
                }
                renderDestinations();
            } catch (error) {
                console.error("Failed to load destinations:", error);
                destinations = [
                    { id: 1, url: "rtmp://live.twitch.tv/app/", key: "", enabled: false },
                    { id: 2, url: "rtmp://a.rtmp.youtube.com/live2/", key: "", enabled: false },
                    { id: 3, url: "rtmps://live-api-s.facebook.com:443/rtmp/", key: "", enabled: false },
                    { id: 4, url: "rtmp://rtmp.kick.com:1935/live/", key: "", enabled: false }
                ];
                renderDestinations();
            }
        }

        async function loadVideos(forceReload = false) {
            try {
                const response = await fetch("/videos");
                const data = await response.json();
                
                // Store current selection before updating
                const currentSelection = videoSelect.value;
                
                videoSelect.innerHTML = "";
                
                if (data.videos && data.videos.length > 0) {
                    data.videos.forEach(video => {
                        const option = document.createElement("option");
                        option.value = video;
                        option.textContent = video;
                        videoSelect.appendChild(option);
                    });
                    
                    // Restore selection
                    if (currentSelection && videoSelect.querySelector(`option[value="${currentSelection}"]`)) {
                        videoSelect.value = currentSelection;
                        currentVideoSelection = currentSelection;
                    } else if (initiallySelectedVideo && initiallySelectedVideo !== 'None' && videoSelect.querySelector(`option[value="${initiallySelectedVideo}"]`)) {
                        videoSelect.value = initiallySelectedVideo;
                        currentVideoSelection = initiallySelectedVideo;
                    } else if (currentVideoSelection && videoSelect.querySelector(`option[value="${currentVideoSelection}"]`)) {
                        videoSelect.value = currentVideoSelection;
                    } else if (data.videos.length > 0) {
                        // Select first video as fallback
                        videoSelect.value = data.videos[0];
                        currentVideoSelection = data.videos[0];
                    }
                } else {
                    const option = document.createElement("option");
                    option.value = "";
                    option.textContent = "No videos found in this category";
                    videoSelect.appendChild(option);
                    currentVideoSelection = "";
                }
            } catch (error) {
                console.error("Failed to load videos:", error);
                videoSelect.innerHTML = '<option value="">Error loading videos</option>';
                currentVideoSelection = "";
            }
        }

        // Destination management functions
        function renderDestinations() {
            destinationsContainer.innerHTML = '';
            
            destinations.forEach((dest, index) => {
                const destDiv = document.createElement('div');
                destDiv.className = 'destination-row';
                destDiv.dataset.id = dest.id;
                
                destDiv.innerHTML = `
                    <div class="destination-counter">Destination ${index + 1}</div>
                    ${destinations.length > 1 ? '<button type="button" class="btn-remove-destination" onclick="removeDestination(' + index + ')">×</button>' : ''}
                    <div class="form-check form-switch mb-2">
                        <input class="form-check-input destination-enabled" type="checkbox" 
                               id="dest-${dest.id}-enabled" ${dest.enabled ? 'checked' : ''}>
                        <label class="form-check-label" for="dest-${dest.id}-enabled">Enable this destination</label>
                    </div>
                    <div class="destination-inputs">
                        <input type="url" class="form-control destination-url" 
                               placeholder="rtmp://live.platform.com/app/" 
                               value="${dest.url || ''}">
                        <input type="text" class="form-control destination-key" 
                               placeholder="Stream key" 
                               value="${dest.key || ''}">
                    </div>
                `;
                
                destinationsContainer.appendChild(destDiv);
                
                // Add event listeners for this destination
                destDiv.querySelector('.destination-enabled').addEventListener('change', (e) => {
                    destinations[index].enabled = e.target.checked;
                });
                destDiv.querySelector('.destination-url').addEventListener('input', (e) => {
                    destinations[index].url = e.target.value;
                });
                destDiv.querySelector('.destination-key').addEventListener('input', (e) => {
                    destinations[index].key = e.target.value;
                });
            });
        }

        function addDestination() {
            destinations.push({
                id: nextId++,
                url: "",
                key: "",
                enabled: false
            });
            renderDestinations();
        }

        window.removeDestination = function(index) {
            if (destinations.length > 1) {
                destinations.splice(index, 1);
                renderDestinations();
            }
        };

        window.saveDestinations = async function() {
            try {
                // Prepare destinations data in the correct format
                const destinationsData = destinations.map((dest, index) => ({
                    id: dest.id.toString(),
                    name: `Destination ${index + 1}`,
                    url: dest.url,
                    key: dest.key,
                    enabled: dest.enabled,
                    type: dest.url.includes('rtmps://') ? 'rtmps' : 'rtmp',
                    status: dest.enabled && dest.key ? 'active' : 'inactive'
                }));

                const response = await fetch("/destinations", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(destinationsData)
                });
                
                if (!response.ok) {
                    const data = await response.json();
                    showMessage(data.error || "Failed to save destinations", "danger");
                } else {
                    const data = await response.json();
                    showMessage(data.message || "Destinations saved successfully", "success");
                }
            } catch (error) {
                showMessage("Network error: " + error.message, "danger");
            }
        };

        window.resetDestinations = function() {
            if (confirm("Reset all destinations to default settings?")) {
                destinations = [
                    { id: 1, url: "rtmp://live.twitch.tv/app/", key: "", enabled: false },
                    { id: 2, url: "rtmp://a.rtmp.youtube.com/live2/", key: "", enabled: false },
                    { id: 3, url: "rtmps://live-api-s.facebook.com:443/rtmp/", key: "", enabled: false },
                    { id: 4, url: "rtmp://rtmp.kick.com:1935/live/", key: "", enabled: false }
                ];
                nextId = 5;
                renderDestinations();
                showMessage("Destinations reset to defaults", "success");
            }
        };

        // Utility functions
        function showMessage(message, type = 'danger') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
            alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" aria-label="Close" onclick="this.parentElement.remove()"></button>
            `;
            messagesDiv.appendChild(alertDiv);
            setTimeout(() => {
                if (alertDiv.parentNode) alertDiv.remove();
            }, 5000);
        }

        function clearMessages() {
            messagesDiv.innerHTML = '';
        }

        function validateForm() {
            const bitrate = document.getElementById('bitrate').value.trim();
            const inputTypeVal = inputType.value;
            const srtUrl = document.getElementById('srt_url').value.trim();
            const selectedVideo = videoSelect.value;
            
            const enabledDestinations = destinations.filter(dest => dest.enabled && dest.url && dest.key);
            if (enabledDestinations.length === 0) {
                showMessage('At least one destination must be enabled with both URL and stream key');
                return false;
            }
            if (!bitrate.match(/^\d+k?$/)) {
                showMessage('Invalid bitrate format. Use format like "2500k" or "2500"');
                return false;
            }
            if (inputTypeVal === 'file' && !selectedVideo) {
                showMessage('Please select a video file to stream');
                return false;
            }
            if (inputTypeVal === 'srt' && !srtUrl) {
                showMessage('SRT/RTMP input URL is required when using stream input');
                return false;
            }
            return true;
        }

        function toggleInputDisplay() {
            if (inputType.value === "file") {
                videoSelection.style.display = "block";
                srtInput.style.display = "none";
            } else {
                videoSelection.style.display = "none";
                srtInput.style.display = "block";
            }
        }

        function populatePresets() {
            const encoderVal = encoder.value;
            const options = PRESET_OPTIONS[encoderVal] || {};
            
            preset.innerHTML = "";
            Object.entries(options).forEach(([value, label]) => {
                const option = document.createElement("option");
                option.value = value;
                option.textContent = label;
                preset.appendChild(option);
            });
            
            // Set the preset from form settings if available
            const formPreset = "{{ form.preset }}";
            if (formPreset && formPreset !== 'None' && options[formPreset]) {
                preset.value = formPreset;
            } else {
                const defaultPreset = DEFAULT_PRESETS[encoderVal] || "medium";
                preset.value = defaultPreset;
            }
            
            encoderHelp.textContent = ENCODER_HELP[encoderVal] || "";
            presetHelp.textContent = `Selected: ${options[preset.value] || preset.value}`;
        }

        function updateStats(data) {
            if (data.running) {
                const uptime = data.uptime ? Math.floor(data.uptime / 60) : 0;
                const restarts = data.restarts || 0;
                const videoInfo = data.current_video ? ` • Now playing: ${data.current_video}` : '';
                statsText.textContent = `Streaming to ${data.enabled_destinations} platforms • ${uptime}m uptime • ${restarts} restarts${videoInfo}`;
                skipBtn.disabled = false;
            } else {
                const videoCount = data.video_count || 0;
                const enabledCount = destinations.filter(d => d.enabled).length;
                statsText.textContent = `Ready to stream • ${videoCount} videos available • ${enabledCount} destinations enabled`;
                skipBtn.disabled = true;
            }
            shuffleMode.checked = data.shuffle_mode || false;
        }

        // API functions
        async function pollStatus() {
            try {
                const response = await fetch("/status");
                const data = await response.json();
                
                // Sync category UI if changed on backend
                if (data.current_category && data.current_category !== currentCategory) {
                    updateCategoryUI(data.current_category);
                    currentCategory = data.current_category;
                }
                
                updateStats(data);
                
                if (data.running) {
                    statusDot.classList.remove("offline");
                    statusDot.classList.add("online");
                    statusDot.title = "Streaming";
                    toggleText.textContent = "Stop Stream";
                    toggleBtn.classList.remove("btn-start");
                    toggleBtn.classList.add("btn-stop");
                } else {
                    statusDot.classList.remove("online");
                    statusDot.classList.add("offline");
                    statusDot.title = "Offline";
                    toggleText.textContent = "Start Stream";
                    toggleBtn.classList.remove("btn-stop");
                    toggleBtn.classList.add("btn-start");
                }
            } catch (error) {
                console.error("Failed to get status:", error);
            }
        }

        async function pollLogs() {
            try {
                const response = await fetch("/logs");
                const data = await response.json();
                const lines = data.lines || [];
                
                logsEl.textContent = lines.join("\n");
                logsEl.scrollTop = logsEl.scrollHeight;
            } catch (error) {
                console.error("Failed to get logs:", error);
            }
        }

        async function skipVideo() {
            try {
                const response = await fetch("/skip", { method: "POST" });
                const data = await response.json();
                
                if (!response.ok) {
                    showMessage(data.error || "Failed to skip video", "danger");
                } else {
                    showMessage("Skipping to next video", "success");
                    await pollStatus();
                }
            } catch (error) {
                showMessage("Network error: " + error.message, "danger");
            }
        }

        async function toggleShuffle() {
            try {
                const response = await fetch("/shuffle", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ shuffle: shuffleMode.checked })
                });
                
                if (!response.ok) {
                    const data = await response.json();
                    showMessage(data.error || "Failed to toggle shuffle", "danger");
                    shuffleMode.checked = !shuffleMode.checked;
                } else {
                    const data = await response.json();
                    showMessage(data.message || `Shuffle mode ${data.shuffle ? 'enabled' : 'disabled'}`, "success");
                }
            } catch (error) {
                showMessage("Network error: " + error.message, "danger");
                shuffleMode.checked = !shuffleMode.checked;
            }
        }

        // Global functions
        window.clearLogs = function() {
            logsEl.textContent = "";
        };

        // Initialize everything
        document.addEventListener("DOMContentLoaded", function() {
            // Category button event listeners
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    setCategory(this.dataset.category);
                });
            });

            // Set initial category from form
            const initialCategory = "{{ stream_state.current_category if stream_state else 'all' }}";
            if (initialCategory && initialCategory !== 'None') {
                updateCategoryUI(initialCategory);
                currentCategory = initialCategory;
            }

            // Track video selection changes
            videoSelect.addEventListener('change', function() {
                currentVideoSelection = this.value;
            });

            // Update category stats periodically
            setInterval(updateCategoryStats, 10000);
            
            // Start polling
            setInterval(pollStatus, 3000);
            setInterval(pollLogs, 2000);

            loadDestinations();
            loadVideos();
            toggleInputDisplay();
            populatePresets();
            updateCategoryStats();
            pollStatus();
            pollLogs();
        });

        // Event listeners
        addDestinationBtn.addEventListener("click", addDestination);
        toggleBtn.addEventListener("click", async function() {
            if (!validateForm()) return;
            clearMessages();
            try {
                toggleBtn.disabled = true;
                
                // Create form data manually to ensure all values are captured
                const formData = new FormData();
                
                // Add form values
                formData.append("bitrate", document.getElementById("bitrate").value);
                formData.append("input_type", inputType.value);
                formData.append("encoder", encoder.value);
                formData.append("preset", preset.value);
                formData.append("shuffle_mode", shuffleMode.checked ? "true" : "false");
                
                // Add video or SRT URL based on input type
                if (inputType.value === "file") {
                    formData.append("video", videoSelect.value);
                } else {
                    formData.append("srt_url", document.getElementById("srt_url").value);
                }
                
                const response = await fetch("/toggle", { 
                    method: "POST", 
                    body: formData 
                });
                
                const data = await response.json();
                if (!response.ok) {
                    showMessage(data.error || "Failed to toggle stream", "danger");
                } else {
                    showMessage(data.message || "Stream toggled", "success");
                }
                await pollStatus();
                await pollLogs();
            } catch (error) {
                showMessage("Network error: " + error.message, "danger");
            } finally {
                toggleBtn.disabled = false;
            }
        });
        skipBtn.addEventListener("click", skipVideo);
        shuffleMode.addEventListener("change", toggleShuffle);
        encoder.addEventListener("change", populatePresets);
        inputType.addEventListener("change", toggleInputDisplay);
        preset.addEventListener("change", function() {
            const options = PRESET_OPTIONS[encoder.value] || {};
            presetHelp.textContent = `Selected: ${options[preset.value] || preset.value}`;
        });
    </script>
</body>
</html>
