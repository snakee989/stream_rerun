<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rerun 24/7 Streaming</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0f14;
      --card: #121821;
      --muted: #93a4b8;
      --text: #e6edf3;
      --line: #1f2a37;
      --primary: #3b82f6;
      --primary-hover: #2563eb;
      --secondary: #475569;
      --secondary-hover: #334155;
      --danger: #ef4444;
      --success: #22c55e;
      --accent: #8b5cf6;
      --input-bg: #0e141b;
    }
    @media (prefers-color-scheme: dark) { :root { color-scheme: dark; } }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 24px; color: var(--text);
      background: radial-gradient(1200px 800px at 20% -10%, #0e1420 0%, var(--bg) 60%) no-repeat,
                  radial-gradient(900px 600px at 120% 10%, rgba(59,130,246,0.08) 0%, rgba(59,130,246,0) 60%) no-repeat,
                  var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    h1 { margin: 0 0 0.25rem 0; font-weight: 700; letter-spacing: 0.2px; }
    small { color: var(--muted); }
    .status { display: inline-flex; align-items: center; gap: 10px; margin-top: 6px; }
    .dot { width: 10px; height: 10px; border-radius: 999px; background: var(--danger); box-shadow: 0 0 0 3px rgba(239,68,68,0.15); }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 18px; margin-top: 18px; }
    .card {
      background: linear-gradient(180deg, rgba(18,24,33,0.92), rgba(18,24,33,0.92)) padding-box,
                  linear-gradient(145deg, rgba(59,130,246,0.15), rgba(139,92,246,0.08)) border-box;
      border: 1px solid transparent; border-radius: 12px; padding: 14px; backdrop-filter: blur(6px);
    }
    label { display: block; margin: 12px 0 6px; color: var(--muted); font-size: 13px; }
    input[type=text], input[type=url], select {
      width: 100%; padding: 10px 11px; background: var(--input-bg); color: var(--text);
      border: 1px solid var(--line); border-radius: 8px; outline: none; transition: border-color .15s, box-shadow .15s;
    }
    input[type=text]:focus, input[type=url]:focus, select:focus {
      border-color: var(--primary); box-shadow: 0 0 0 3px rgba(59,130,246,0.25);
    }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .btn {
      padding: 10px 14px; background: var(--primary); color: white; border: 1px solid rgba(255,255,255,0.06);
      cursor: pointer; border-radius: 8px; transition: background .15s, transform .02s;
    }
    .btn:hover { background: var(--primary-hover); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background: var(--secondary); }
    .btn.secondary:hover { background: var(--secondary-hover); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .muted { color: var(--muted); }
    pre {
      background: #0a0f16; color: #d2d8de; padding: 12px; border-radius: 10px; border: 1px solid var(--line);
      height: 280px; overflow: auto; font-size: 12.5px; line-height: 1.35;
    }
    .hidden { display: none; }
    .tag {
      display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px;
      background: rgba(139,92,246,0.18); color: #dcd2ff; border: 1px solid rgba(139,92,246,0.35); margin-left: 8px;
    }
    .header { display: flex; align-items: baseline; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Rerun 24/7 Streaming <span class="tag" id="encTag">Ready</span></h1>
    <div class="status">
      <span id="statusText" class="muted">Stopped</span>
      <span id="statusDot" class="dot" title="Stopped"></span>
    </div>
  </div>
  <small class="muted">GPU Support: NVIDIA (NVENC), Intel (VAAPI); CPU encoding works everywhere.</small>

  <!-- embed saved config from backend -->
  <script id="saved-config" type="application/json">
    {{ form|tojson }}
  </script>

  <form id="control-form">
    <div class="grid">
      <div class="card">
        <label>Stream Key / Output URL</label>
        <input type="text" id="stream_key" name="stream_key" placeholder="rtmp://server/app/streamKey" required />

        <label>Video Bitrate</label>
        <input type="text" id="bitrate" name="bitrate" value="2500k" />

        <label>Input Source</label>
        <div class="row">
          <label><input type="radio" name="input_type" value="file" checked /> Local Video File</label>
          <label><input type="radio" name="input_type" value="srt" /> SRT / RTMP Stream</label>
        </div>

        <div id="fileInputs">
          <label>Category</label>
          <select id="category" name="category"></select>

          <label>Shuffle Playlist</label>
          <label class="row" style="gap:8px;">
            <input type="checkbox" id="shuffle" name="shuffle" />
            <span class="muted">Shuffle across category</span>
          </label>

          <label>Select Video</label>
          <select id="video" name="video"></select>
        </div>

        <div id="srtInputs" class="hidden">
          <label>SRT / RTMP Input URL</label>
          <input type="url" id="srt_url" name="srt_url" placeholder="srt://host:port?mode=listener" />
        </div>
      </div>

      <div class="card">
        <label>Video Encoder</label>
        <select id="encoder" name="encoder">
          <option value="libx264">CPU (x264)</option>
          <option value="h264_nvenc">NVIDIA GPU (NVENC)</option>
          <option value="h264_vaapi">Intel iGPU (VAAPI)</option>
        </select>

        <label>Encoder Preset</label>
        <select id="preset" name="preset"></select>

        <div class="row" style="margin-top: 12px;">
          <button class="btn" id="startStopBtn" type="button">Start Stream</button>
          <button class="btn secondary" id="clearLogsBtn" type="button">Clear Logs</button>
          <button class="btn secondary" id="rescanBtn" type="button">Rescan</button>
        </div>
      </div>

      <div class="card">
        <label>Logs</label>
        <pre id="logs"></pre>
      </div>
    </div>
  </form>

  <script>
    // Human-readable preset labels mapped to exact values the backend expects
    const presetsByEncoder = {
      // libx264 presets (single clear "Default" only)
      libx264: [
        { value: "ultrafast", label: "Lowest Quality (Fastest)" },
        { value: "superfast", label: "Very Fast" },
        { value: "veryfast",  label: "Faster" },
        { value: "faster",    label: "Fast" },
        { value: "fast",      label: "Fast (lower quality)" },
        { value: "medium",    label: "Default" },
        { value: "slow",      label: "Higher Quality" },
        { value: "slower",    label: "High Quality" },
        { value: "veryslow",  label: "Highest Quality (Slowest)" },
        { value: "placebo",   label: "Max Quality (Very Slow)" },
      ],
      // NVIDIA NVENC p1..p7
      h264_nvenc: [
        { value: "p1", label: "Lowest Quality (Fastest)" },
        { value: "p2", label: "Very Fast" },
        { value: "p3", label: "Fast" },
        { value: "p4", label: "Default" },
        { value: "p5", label: "Quality" },
        { value: "p6", label: "High Quality" },
        { value: "p7", label: "Highest Quality (Slowest)" },
      ],
      // VAAPI compression_level 1..7
      h264_vaapi: [
        { value: "1", label: "Lowest Quality (Fastest)" },
        { value: "2", label: "Very Fast" },
        { value: "3", label: "Fast" },
        { value: "4", label: "Default (Balanced)" },
        { value: "5", label: "Quality" },
        { value: "6", label: "High Quality" },
        { value: "7", label: "Highest Quality (Slowest)" },
      ],
    };

    // Parse saved config embedded by backend
    const saved = (() => {
      try { return JSON.parse(document.getElementById('saved-config')?.textContent || '{}'); }
      catch { return {}; }
    })();

    function populatePresets() {
      const enc = document.getElementById('encoder').value;
      const presetEl = document.getElementById('preset');
      const current = presetEl.value;
      presetEl.innerHTML = "";
      (presetsByEncoder[enc] || []).forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.value;
        opt.textContent = p.label;
        presetEl.appendChild(opt);
      });
      // Defaults per encoder
      let defaultVal = 'medium';
      if (enc === 'h264_nvenc') defaultVal = 'p5';
      if (enc === 'h264_vaapi') defaultVal = '4';

      // Apply saved or fallback default
      const desired = saved.preset && [...presetEl.options].some(o => o.value === saved.preset)
        ? saved.preset : defaultVal;
      presetEl.value = desired;

      // Update tag to show encoder + label
      const tag = document.getElementById('encTag');
      const label = [...presetEl.options].find(o => o.value === presetEl.value)?.textContent || '';
      tag.textContent = `${enc} Â· ${label}`;
    }

    function applyStatus(s) {
      const btn = document.getElementById('startStopBtn');
      const dot = document.getElementById('statusDot');
      const txt = document.getElementById('statusText');
      const logs = document.getElementById('logs');

      const running = !!(s && s.running);
      btn.textContent = running ? 'Stop Stream' : 'Start Stream';
      btn.dataset.running = running ? '1' : '0';

      dot.style.backgroundColor = running ? 'var(--success)' : 'var(--danger)';
      dot.style.boxShadow = running
        ? '0 0 0 3px rgba(34,197,94,0.18)'
        : '0 0 0 3px rgba(239,68,68,0.15)';
      dot.title = running ? 'Streaming' : 'Stopped';

      const restarts = s && typeof s.restarts === 'number' ? s.restarts : 0;
      txt.textContent = running ? `Streaming (restarts: ${restarts})` : 'Stopped';

      if (logs && s && s.tail) {
        logs.textContent = s.tail.join('\n');
        logs.scrollTop = logs.scrollHeight;
      }
    }

    async function pollStatus() {
      try {
        const r = await fetch('/status', { cache: 'no-store' });
        const s = await r.json();
        applyStatus(s);
      } catch (e) {}
    }

    async function loadCategories(selected) {
      try {
        const r = await fetch('/categories');
        const data = await r.json();
        const sel = document.getElementById('category');
        sel.innerHTML = '';
        (data.categories || []).forEach(c => {
          const opt = document.createElement('option');
          opt.value = c; opt.textContent = c; sel.appendChild(opt);
        });
        if (selected && [...sel.options].some(o => o.value === selected)) sel.value = selected;
      } catch (e) {}
    }

    async function loadVideos(category, selected) {
      try {
        const r = await fetch(`/videos?category=${encodeURIComponent(category)}`);
        const data = await r.json();
        const sel = document.getElementById('video');
        sel.innerHTML = '';
        (data.videos || []).forEach(v => {
          const opt = document.createElement('option');
          opt.value = v; opt.textContent = v; sel.appendChild(opt);
        });
        if (selected && [...sel.options].some(o => o.value === selected)) sel.value = selected;
      } catch (e) {}
    }

    function updateInputVisibility() {
      const type = document.querySelector('input[name="input_type"]:checked').value;
      document.getElementById('fileInputs').classList.toggle('hidden', type !== 'file');
      document.getElementById('srtInputs').classList.toggle('hidden', type !== 'srt');
    }

    function applySavedBasics() {
      if (saved.stream_key) document.getElementById('stream_key').value = saved.stream_key;
      if (saved.bitrate) document.getElementById('bitrate').value = saved.bitrate;

      const it = (saved.input_type || 'file').toLowerCase();
      const sel = document.querySelector(`input[name="input_type"][value="${it}"]`);
      if (sel) sel.checked = true;

      const sh = (saved.shuffle || '').toString().toLowerCase();
      document.getElementById('shuffle').checked = ['on','true','1','yes'].includes(sh);

      if (saved.encoder) document.getElementById('encoder').value = saved.encoder;
      populatePresets();
    }

    async function toggleStream() {
      const btn = document.getElementById('startStopBtn');
      const running = btn.dataset.running === '1';
      let body = null;

      if (!running) {
        const fd = new FormData(document.getElementById('control-form'));
        fd.set('shuffle', document.getElementById('shuffle').checked ? 'on' : 'off');
        body = fd;
      } else {
        body = new FormData();
      }

      try {
        const r = await fetch('/toggle', { method: 'POST', body });
        await r.json().catch(() => ({}));
      } catch (e) {}
      setTimeout(pollStatus, 300);
    }

    window.addEventListener('load', async () => {
      applySavedBasics();
      updateInputVisibility();

      await loadCategories(saved.category || '');
      const cat = document.getElementById('category').value;
      if (cat) await loadVideos(cat, saved.video || '');

      document.getElementById('encoder').addEventListener('change', populatePresets);
      document.getElementById('preset').addEventListener('change', populatePresets);
      document.getElementById('category').addEventListener('change', async (e) => {
        await loadVideos(e.target.value, '');
      });
      document.querySelectorAll('input[name="input_type"]').forEach(r => {
        r.addEventListener('change', updateInputVisibility);
      });
      document.getElementById('startStopBtn').addEventListener('click', toggleStream);
      document.getElementById('clearLogsBtn').addEventListener('click', async () => {
        try { await fetch('/logs/clear', { method: 'POST' }); } catch (e) {}
        setTimeout(pollStatus, 200);
      });
      document.getElementById('rescanBtn').addEventListener('click', async () => {
        try { await fetch('/rescan', { method: 'POST' }); } catch (e) {}
        await loadCategories(saved.category || '');
        const cat2 = document.getElementById('category').value;
        if (cat2) await loadVideos(cat2, saved.video || '');
      });

      setInterval(pollStatus, 2000);
      await pollStatus();
    });
  </script>
</body>
</html>
